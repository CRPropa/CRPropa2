/**
   @file    sophiainteractions.h
   @author  Eric Armengaud, armengau@in2p3.fr
   @brief   Class describing p/n interactions computed with SOPHIA
*/


#ifndef _SOPHIAINTERACTIONS_H_
#define _SOPHIAINTERACTIONS_H_

#include "interactiondata.h"
//#include "TALYSMeanFreePathAccurate.h"
//#include "TALYSMeanFreePathAvrgd.h"
#include "TALYSMeanFreePathTabulated.h"
#include "units.h"
#include "xmlparam.h"
#include "crp_err.h"

#include "CLHEP/Random/RandFlat.h"

#include <vector>
#include <fstream>
#include <math.h>
#include <string.h>
#include <algorithm>
#include "sophia.h"
#include "sibyll.h"   // LM

//#ifdef HAVE_TROOT_H
#include <TH2F.h>
#include <TCanvas.h>
#include <TProfile.h>
#include <TLine.h>
#include <TFile.h>
#include <TGraph.h>
#include <sstream>
#include <TLegend.h>
#include <TColor.h>
#include "IRBzEvolutionFactory.h"

//#endif

/**
   @class TSophiaInteractions
   @brief Class describing nucleon interactions to use the SOPHIA event generator.

*/

class TIRBzEvolutionModel;

class TSophiaInteractions : public TInteractionData, public TXmlParam {
 public:
  TSophiaInteractions(const char*,TIRBzEvolutionModel*) ;
  ~TSophiaInteractions() ;

  string ShowerTableDir() const { return _fShowerTableDir; }
  /**< Directory where the electromagnetic interaction tables must be read by DINT. */

  double L_pair(int i) const { 
    try {
      return _fL_pair.at(i); 
    }catch(exception& e){ 
      std::cout<< "Exception L_pair i: " << i << " _fL_pair.size() " << _fL_pair.size() << std::endl;
      std::cout<< "e.what() " << e.what() << std::endl;
    }
  }
  /**< Energy loss length by pair production for protons. */
  double E_part(int i) const { 
    try{
      return _fE_part.at(i); 
    } catch(exception& e){ 
      std::cout<< "Exception E_part i: " << i << " _fE_part.size() " << _fE_part.size() << std::endl;
      std::cout<< "e.what() " << e.what() << std::endl;
    }
  }
  /**< Energy grid for the pair production loss array. */
  double dEtabbin() const { return _fdEtabbin; }
  /**< Logarithmic bin for the energy grid of pair production loss array.*/
  double E_pionprod(int i) const { return _fE_pionprod.at(i); }
  /**< Energy grid for the pion production arrays. */
  double E_IRpionprod(int i) const { return _fE_IRpionprod.at(i); }
  /**< Energy grid for the pion production arrays. */
  double LossRateProton(int i) const { return _fLossRateProton.at(i); }
  /**< Pion production rate on the CMB for protons. */
  double LossRateNeutron(int i) const { return _fLossRateNeutron.at(i); }
  /**< Pion production rate on the CMB for neutrons. */
  double IRLossRateProton(int i) const { return _fIRLossRateProton.at(i); }
  /**< Pion production rate on the IRB for protons. */
  double IRLossRateNeutron(int i) const { return _fIRLossRateNeutron.at(i); }
  /**< Pion production rate on the IRB for neutrons. */
  double dEtabPion() const { return _fdEtabPion; }
  /**< Logarithmic bin for the energy grid of pin production loss arrays.*/
  double dEtabIRPion() const { return _fdEtabIRPion; }
  /**< Logarithmic bin for the energy grid of pin production loss arrays.*/

  bool KelnerPairProdFlag() const { return _fKelnerPairProdFlag; }
  /**< Set to 1 uses the Kelner formula to compute the pair production electron spectrum. Otherwise use a power law model. Default flag is 1. */
  bool SecPairProdPhotonFlag() const { return _fSecPairProdPhotonFlag; }
  /**< Set to 1 allows to follow secondary electromagnetic cascades generated by pair production. Set to 0 by default. */
  double SecPairProdPhotonProba() const { return _fSecPairProdPhotonProba; }
  /**< Probability to follow effectively the secondary photons if SecPairProdPhotonFlag() is switched on. By default, it is 1. Useful to apply weighting procedures. */
  bool PairProdFlag() const { return _fPairProdFlag; }
  /**< Set to 1 switches pair production on. Default is 1. */
  bool IRPionProdFlag() const { return _fIRPionProdFlag; }
  /**< Set to 1 switches on pion production on the IRB. Default is 1. */
  bool PionProdFlag() const { return _fPionProdFlag; }
  /**< Set to 1 switches on pion production on the CMB. Default is 1. */
   bool  PhotodisintegrationFlag() const { return _fPhotodisintegrationFlag; }
  /**< If set, photodisintegration will be taken into account. */
   bool  IRPhotodisintegrationFlag() const { return _fIRPhotodisintegrationFlag; }
  /**< If set, photodisintegration on IRB will be taken into account. */
   bool  CMBPhotodisintegrationFlag() const { return _fCMBPhotodisintegrationFlag; }
  /**< If set, photodisintegration on CMB will be taken into account. */
   bool DecayFlag() const {return _fDecayFlag;}
   /**< Set to 1 switches decay on **/
  bool SecPhotonFlag() const { return _fSecPhotonFlag; }
  /**< Set to 1 allows to follow secondary electromagnetic cascades generated by pion production and neutron decay. Set to 0 by default. */
  bool SecNuFlag() const { return _fSecNuFlag; }
  /**< Set to 1 allows to follow secondary neutrinos generated by pion production and neutron decay. Set to 0 by default. */
  bool RedshiftFlag() const { return _fRedshiftFlag; }
  /**< Set to 1 switches on redshift energy losses and scaling of Mean free pathes. Default is 1. */
  bool RedshiftEnergyLossFlag() const { return _fNoRedshiftEnergyLossFlag; }
  /**< Set to 1 switches on redshift energy losses only.  Does not effect scaling of mean free pathes.Default is 1. */
  double CutcascadeFlag() const { return _fCutcascadeFlag; }
  /**< If non zero, "cuts" the e+/- cascade by the magnetic deflections in DINT: only the electrons with  r_Larmor > CutcascadeFlag() * min(t_synchrotron,t_ICS) are kept */
  double PairProdSpec(double, int) const ;
  /**< Returns the interpolated pair production spectrum for a given nucleon energy, at a given electron energy bin. The spectrum is E^2 dN/dE in eV/s, where N=N(e-)=N(e+). */
  RandGeneral* RandDistriNeutronDecay() const { return _fpRandDistriNeutronDecay; }
  /**< Energy distribution of the outcoming electron when a neutron decay takes place. */
  double GetPPEps() const {return _fPairProdEps;}
  /**< Returns the pair production safety factor >**/

  /**< Returns a vector which represents the nucleus transition: 
     1. component = input nuleus, 
     2. component = output nucleus, 
     3. component = DeltaCharge,
     4. component = DeltaMass.
  If no reaction takes place the 2. component is set to 0.*/
  /*vector <unsigned long int> 
    GetNucleusTransition(unsigned long int InitNucleusId,
			 TVector3D Position,
			 double Energy,
			 double NucleusMass,
			 double z,
			 double TimeStep);*/
  /**< If an Nucelus reaction took place this function can be used to choose an exclusive channel. */

  /*
    unsigned long int GetExclusiveChannel(unsigned long int InitNucleusId,
    unsigned long int OutNucleusId, 
    double Energy,
    double NucleusMass,
    int DeltaCharge,
    int DeltaMass,
    double z,
    double TimeStep);*/

  unsigned long int GetExclusivePDChannelDirectly(unsigned long int InitNucleusId,
						TVector3D Position,
						double Energy,
						double NucleusMass,
						double z,
						double TimeStep);

  double GetPDTimeStep(unsigned long int InitNucleusId,
		     TVector3D Position,
		     double Energy,
		     double NucleusMass,
		     double z);
  
  //#ifdef HAVE_TROOT_H
  /*Delete*/
  /*void RootPlotMeanFreePathVsEnergy(unsigned long int InputNucleusId,
				    double EnergyMinGeV,
				    double EnergyMaxGeV,
				    double EnergySteps,
				    double DistanceStepMpc,
				    int NEventsPerEnergy,
				    double NucleusMass);*/
  
  
  /*TGraph* RootPlotMeanFreePathAvrgVsGammaNumerically
    (unsigned long int InputNucleusId,
     double gammaMin,
     double gammaMax,
     double gammaSteps,
     double redshift);*/
  
  /*TGraph* RootPlotMeanFreePathAccVsGammaNumerically
    (unsigned long int InputNucleusId,
     double gammaMin,
     double gammaMax,
     double gammaSteps,
     double redshift);*/
  
/*   void RootFileWithAllMFPs(TabulatedTALYSY* TabulatedTALYSY, */
/* 			   double fXMin, */
/* 			   double fXMax, */
/* 			   double fXNSteps, */
/* 			   double redshift ); */
  
/*   TGraph* RootPlotYVsX(TabulatedTALYSY* TabulatedTALYSY, */
/* 		       unsigned long int InputNucleusId, */
/* 		       long unsigned int OutId, */
/* 		       double fXMin, */
/* 		       double fXMax, */
/* 		       double fXNSteps, */
/* 		       double redshift, */
/* 		       int TotalSumOrExclusive); */
  
/*   TGraph* RootPlotExclSumYVsX(TabulatedTALYSY* TabulatedTALYSY, */
/* 			      unsigned long int InputNucleusId, */
/* 			      double fXMin, */
/* 			      double fXMax, */
/* 			      double fXNSteps, */
/* 			      double redshift); */
  //#endif
  
  double E_PP(int i) const { return _fE_PP.at(i); }
  /**< Energy grid for the proton proton interaction arrays. */
  double XSecPPProton(int i) const { return _fXSecPPProton.at(i); }
  /**< PP interaction cross section for protons. */
  double XSecPPProton(double);
  /**< Interpolated PP interaction cross section for protons. */
  double IRXsecInt_Proton(int i, int j) const { return _fIRXsecInt_Proton.at(i*1000+j); }
  double IRXsecInt_Neutron(int i, int j) const { return _fIRXsecInt_Neutron.at(i*1000+j); }
  double E_IR(int i) const { return _fE_IR.at(i); }
  double S_IR(int i) const { return _fS_IR.at(i); }
  double dEtabXsecIR() const { return _fdEtabXsecIR; }
  double dStabXsecIR() const { return _fdStabXsecIR; }
  std::vector<TabulatedTALYSY*> GetPointerToPhotoDisTables();
  bool PProdFlag() const { return _fPProdFlag; }
  /**< Set to 1 switches on proton proton interactions. Default is 0. */

  protected:
  vector<double> _fL_pair ; // pair production : from old f77 code
  vector<double> _fE_part ; // (including units)
  double _fdEtabbin ;
  //double _fZmaxIRB;
  vector<double> _fE_pionprod ; // pion production : tables from SOPHIA
  vector<double> _fE_IRpionprod ; // pion production : tables from SOPHIA
  vector<double> _fLossRateProton ; // standard units
  vector<double> _fLossRateNeutron ;
  vector<double> _fIRLossRateProton ; // same for pion production on the Primack CIB
  vector<double> _fIRLossRateNeutron ;
  double _fdEtabPion ;
  double _fdEtabIRPion ;

  string _fShowerTableDir ;

  // flags to switch on/off interactions and secondary propagation
  bool _fSecPairProdPhotonFlag ;
  double _fSecPairProdPhotonProba ;
  bool _fPairProdFlag ;
  bool _fKelnerPairProdFlag ;
  bool _fIRPionProdFlag ;
  bool _fPionProdFlag ;
  bool _fSecPhotonFlag ;
  bool _fSecNuFlag ;
  bool _fRedshiftFlag ;
  bool _fNoRedshiftEnergyLossFlag;
  bool _fPhotodisintegration_VarIRBFlag;
  bool _fPhotodisintegrationFlag ;
  bool _fIRPhotodisintegrationFlag ;
  bool _fCMBPhotodisintegrationFlag ;
  bool _fDecayFlag;
  double _fCutcascadeFlag ;

  RandGeneral* _fpRandDistriNeutronDecay ;
   double _fPairProdTable[NBINS_PAIRPROD][NUM_MAIN_BINS];
  double _fNucleonEnergy_PP[NBINS_PAIRPROD];
  vector<double> _fE_PP ; // proton-proton interaction : tables from SIBYLL
  vector<double> _fXSecPPProton ; // standard units
  vector<double> _fIRXsecInt_Proton;
  vector<double> _fIRXsecInt_Neutron;
  vector<double> _fE_IR;
  vector<double> _fS_IR;
  double _fdEtabXsecIR;
  double _fdStabXsecIR;
  double _fPairProdEps;
  bool _fPProdFlag;
  bool _fCreatePDTableFlag;
  bool _fReducePDTableFlag;
    TIRBzEvolutionModel* _fpEvolModel;
    
  //data for photo-disintegration
  std::vector<TabulatedTALYSY*> _fTabulatedTALYSY_Vec;
  
  //"mean free path calculator" on the basis of cross sections data stored in _fTabulatedTALYSY
  TALYSMeanFreePath* _fTALYSMeanFreePathCalc;
  
  //vector to hold the photonfields
  std::vector<PhotonBackground*> _fPhotonBackgrounds_Vec;
};

#endif


